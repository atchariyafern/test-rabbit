import React, { ReactElement, useEffect, useState } from 'react';
import { useFormik } from 'formik';
import { produce } from 'immer';
import { ObjectSchema } from 'yup';
import { AnySchema } from 'yup/lib/schema';
import Reference from 'yup/lib/Reference';
import Lazy from 'yup/lib/Lazy';
import {
  getDefaultAnswer,
  getFollowingQuestions,
  getNextQuestion,
  getNextSection,
  isEndOfSection,
  getQuestionPosition,
} from '../lib/questions';
import Question from './questions/Question';
import MarketingConsent from './questions/MarketingConsent';

export type QuestionFlowProps = {
  t: (s: string) => string;
  initialValues: Record<string, any>;
  initialConfig: Record<string, any>;
  initialQuestionsVisibility: Record<string, boolean>;
  initialSectionsVisibility: Record<string, boolean>;
  initialFurthestQuestion?: string;
  onAnswer: (questionCode: string, values: Record<string, any>) => void;
  onSubmit: (values: Record<string, any>) => void;
  onConfigUpdate: (config: Record<string, any>) => void;
  validationSchema: ObjectSchema<
    Record<string, AnySchema | Reference | Lazy<any, any>>
  >;
  getDynamicChoiceQuestionPatch?: (
    questionCode: string,
    values: Record<string, any>
  ) => Promise<any>;
  marketingConsent: {
    submitLabel: string;
    htmlTop: ReactElement | string;
    htmlBottom: ReactElement | string;
  } | null;
  onShowQuestion: ((code: string) => void) | null;
  scrollToMarketingConsent?: boolean;
  showConfirm?: boolean;
  showSectionHeader?: boolean;
  lastStage: string | null;
  eventQuestionDisplay: (section: string, question: string) => void;
};

const QuestionFlow = ({
  t,
  initialValues,
  initialConfig,
  initialQuestionsVisibility,
  initialSectionsVisibility,
  initialFurthestQuestion,
  onAnswer,
  onSubmit,
  onConfigUpdate,
  validationSchema,
  getDynamicChoiceQuestionPatch,
  marketingConsent = null,
  onShowQuestion = null,
  scrollToMarketingConsent = false,
  showConfirm = false,
  showSectionHeader = false,
  lastStage = null,
  eventQuestionDisplay = () => null,
}: QuestionFlowProps): ReactElement => {
  const [furthestQuestion, setFurthestQuestion] = useState(
    initialFurthestQuestion
  );
  const [questionsVisibility, setQuestionsVisibility] = useState(
    initialQuestionsVisibility
  );
  const [sectionsVisibility, setSectionsVisibility] = useState(
    initialSectionsVisibility
  );
  const [config, setConfig] = useState(initialConfig);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const progressBarSize = 65;

  useEffect(() => {
    onConfigUpdate(config);
  }, [config, onConfigUpdate]);

  const offset = (el: HTMLElement) => {
    const rect = el.getBoundingClientRect();
    const scrollLeft =
      window.pageXOffset || document.documentElement.scrollLeft;
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    return { top: rect.top + scrollTop, left: rect.left + scrollLeft };
  };

  useEffect(() => {
    const $marketConsent = document.getElementById('tc');
    if (scrollToMarketingConsent) {
      setTimeout(() => {
        if ($marketConsent) {
          window.scrollTo({
            top: offset($marketConsent).top - progressBarSize,
            behavior: 'smooth',
          });
        }
      }, 100);
    }
  }, [scrollToMarketingConsent]);

  const formik = useFormik({
    initialValues,
    enableReinitialize: true,
    validationSchema,
    onSubmit: () => undefined,
  });

  /**
   * @param {string} field - field name.
   * @param value
   */
  const setFieldValue = (field: string, value: any) => {
    // For some reason we can't put setFieldValue() before setFieldTouched(),validate on change won't working properly.
    formik.setFieldTouched(field);
    formik.setFieldValue(field, value);
  };

  /**
   * Reset field value
   *
   * @param {array} fields
   */
  const resetFieldsValue = (fields: string[]) => {
    fields.forEach((field) => {
      formik.setFieldValue(field, '');
    });
  };

  const handleDependencies = (
    question: Record<string, any>,
    furthestQuestion: string | undefined,
    config: Record<string, any>
  ) => {
    let hideQuestions: string[] = [];
    if (!question) {
      return hideQuestions;
    }

    if (
      getQuestionPosition(furthestQuestion, config) >
      getQuestionPosition(question.code, config)
    ) {
      if (question.dynamic) {
        hideQuestions = getFollowingQuestions(question, config.sections);
        resetFieldsValue(hideQuestions);
      }
    }

    if (isEndOfSection(question, config.sections)) {
      const nextSectionsVisibility = produce(
        sectionsVisibility,
        (draftState) => {
          draftState[getNextSection(question.section, config.sections)] = true;
        }
      );

      setSectionsVisibility(nextSectionsVisibility);
    }

    return hideQuestions;
  };

  /**
   * Show next question and scrolling user to next question.
   *
   * @param {array} showFields
   * @param {array} hideFields
   */
  const handleQuestionsVisibility = (
    showFields: string[] = [],
    hideFields: string[] = []
  ) => {
    const updateQuestionsVisibility = { ...questionsVisibility };

    hideFields.forEach((field) => {
      updateQuestionsVisibility[field] = false;
    });

    showFields.forEach((field) => {
      updateQuestionsVisibility[field] = true;
    });

    setQuestionsVisibility(updateQuestionsVisibility);
  };

  const handleNextQuestion = async (
    questionConfig: Record<string, any>,
    prevQuestion: string,
    questionCode: string,
    furthestQuestion: string | undefined,
    values: Record<string, any>,
    skipQuestions: any = {}
  ): Promise<any> => {
    if (
      getQuestionPosition(furthestQuestion, config) <
      getQuestionPosition(questionCode, config)
    ) {
      furthestQuestion = questionCode;
    }

    if (questionConfig.questions[questionCode].dynamic) {
      const { shouldSkipNextQuestion, questionConfig: newQuestionConfig } =
        await getDynamicChoiceQuestionPatch(questionCode, values);

      questionConfig = newQuestionConfig;

      if (shouldSkipNextQuestion) {
        values[questionCode] = getDefaultAnswer(
          questionCode,
          questionConfig.questions
        );
        skipQuestions[questionCode] = values[questionCode];

        const nQuestion = getNextQuestion(
          questionCode,
          questionConfig.questionOrder,
          questionConfig.questions
        );

        if (nQuestion) {
          return handleNextQuestion(
            questionConfig,
            questionCode,
            nQuestion,
            furthestQuestion,
            values,
            skipQuestions
          );
        }
      }
    }

    setConfig(questionConfig);
    setFurthestQuestion(furthestQuestion);

    const hideQuestions = handleDependencies(
      questionConfig.questions[prevQuestion],
      furthestQuestion,
      questionConfig
    );

    // Set formik values and hide skip questions.
    Object.keys(skipQuestions).forEach((skipQuestion) => {
      setFieldValue(skipQuestion, skipQuestions[skipQuestion]);
      hideQuestions.push(skipQuestion);
    });

    handleQuestionsVisibility([questionCode], hideQuestions);
    if (onShowQuestion !== null && questionCode !== null) {
      onShowQuestion(config.questions[questionCode]);
    }

    const $nextQuestionBlock = document.getElementById(questionCode);
    // Navigate user to next question
    if ($nextQuestionBlock) {
      setTimeout(() => {
        window.scrollTo({
          top: offset($nextQuestionBlock).top - progressBarSize,
          behavior: 'smooth',
        });
      }, 100);
    }
  };

  const handleNewAnswer = async (questionCode: string, answer: any) => {
    const nextQuestion = getNextQuestion(
      questionCode,
      config.questionOrder,
      config.questions
    );

    const values = {
      ...formik.values,
    };
    if (config.questions[questionCode].type === 'multi_question') {
      config.questions[questionCode].questions.forEach(
        (question: Record<string, any>, index: number) => {
          values[question.code] = answer[index];
        }
      );
    } else {
      values[questionCode] = answer;
    }

    onAnswer(questionCode, values);

    if (nextQuestion) {
      handleNextQuestion(
        config,
        questionCode,
        nextQuestion,
        furthestQuestion,
        values
      );
    }
  };

  const dynamicChoicesFetch = (
    nextQnCode: string,
    field: string,
    value: any,
    dependencyQuestions: string[]
  ) => {
    const formikValues = {
      ...formik.values,
      [field]: value,
    };
    getDynamicChoiceQuestionPatch(nextQnCode, formikValues).then(
      ({ questionConfig: newQuestionConfig }) => {
        setConfig(newQuestionConfig);
      }
    );

    resetFieldsValue(dependencyQuestions);
  };

  useEffect(() => {
    formik.validateForm();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [validationSchema]);

  const handleChange = (field: string, value: any) => {
    const question = config.questions[field];

    setFieldValue(field, value);

    if (
      ![
        'email',
        'phone',
        'text',
        'square_checkboxes',
        'square_checkboxes_vertical',
        'price',
        'rich_multi_choice',
        'multi_select_field',
        'thai_id',
      ].includes(question.type)
    ) {
      handleNewAnswer(field, value);
    }
  };

  const handleSubmit = () => {
    // Send user back to answer missing question.
    // Tc question value is not stored in formik value and submit button activation depends on its value,
    // so it's safely ignored from formik validation.
    formik.validateForm().then((errors) => {
      for (const questionCode of config.questionOrder) {
        if (errors[questionCode] && questionCode !== 'tc') {
          const $errorQuestionBlock = document.getElementById(questionCode);
          formik.setFieldTouched(questionCode);

          if ($errorQuestionBlock) {
            window.scrollTo({
              top: offset($errorQuestionBlock).top - progressBarSize,
            });
          }

          break;
        }
      }

      if (!Object.keys(errors).length) {
        setIsSubmitting(true);
        onSubmit(formik.values);
      }
    });
  };

  return (
    <form>
      {Object.values(config.sections).map(
        (section: { code: string; label: string; questions: any }, index) => {
          // @todo remove this hack, we need to make sure 'tc' field does not appear in Quotes section
          if (section.code === 'quotes') {
            return '';
          }

          return (
            <div
              key={section.code}
              className="form-section rounded mb-md-5 position-relative"
              style={{
                display: sectionsVisibility[section.code] ? 'block' : 'none',
              }}
            >
              <h2 className="text-primary h3 form-section-header d-none d-lg-block">
                {t(section.label)}
              </h2>

              {showSectionHeader && index === 0 && (
                <h3 className="px-2 mobile-form-section-header d-md-none d-lg-none">
                  {t(section.label)}
                </h3>
              )}

              {lastStage === 'confirm' && index === 0 && showConfirm && (
                <p
                  className="pt-0 px-2 pt-lg-4 px-lg-5 mb-0"
                  style={{ color: '#768dac' }}
                >
                  {t(section.label)}
                </p>
              )}

              {section.questions.map(
                (questionName: string, questionIndex: number) => {
                  const question = config.questions[questionName];
                  const bgColor = questionIndex % 2 ? 'bg-question' : '';
                  // make first question visible
                  const active = questionsVisibility[questionName];

                  return (
                    <Question
                      t={t}
                      key={question.code}
                      active={active}
                      bgColor={bgColor}
                      isConfirmButton={showConfirm}
                      handleChange={handleChange}
                      handleNewAnswer={handleNewAnswer}
                      onDynamicQuestionChange={dynamicChoicesFetch}
                      question={question}
                      formik={formik}
                      eventQuestionDisplay={eventQuestionDisplay}
                    />
                  );
                }
              )}
            </div>
          );
        }
      )}
      {config.questions.tc && marketingConsent ? (
        <MarketingConsent
          t={t}
          active={questionsVisibility.tc}
          key="tc"
          value={formik.values[config.questions.tc.code] || null}
          question={config.questions.tc}
          onChange={setFieldValue}
          onSubmit={handleSubmit}
          eventQuestionDisplay={eventQuestionDisplay}
          htmlTop={marketingConsent.htmlTop}
          htmlBottom={marketingConsent.htmlBottom}
          submitLabel={marketingConsent.submitLabel}
          isSubmitting={isSubmitting}
        />
      ) : (
        ''
      )}
    </form>
  );
};

export default QuestionFlow;
