import React, {
  KeyboardEventHandler,
  useEffect,
  useState,
  useMemo,
} from 'react';
import clsx from 'clsx';
import { FormikProps, FormikValues } from 'formik';
import Cleave from 'cleave.js/react';
import TextFieldLayout from '../TextFieldLayout';

export interface PhoneProps {
  t: (s: string) => string;
  isVisible?: boolean;
  showNextButton?: boolean;
  formik: FormikProps<FormikValues> | any;
  handleChange?: (
    event: React.ChangeEvent<HTMLInputElement>,
    value: string
  ) => void;
  question: {
    tipText?: string;
    label: string;
    code: string;
  };
  handleNextButton?: (fieldName: string, values: Record<string, any>) => void;
  fieldName?: string;
  isConfirmButton?: boolean;
  ref?: HTMLDivElement;
}

const Phone: React.FC<PhoneProps & React.HTMLProps<HTMLInputElement>> = ({
  t,
  isVisible = true,
  showNextButton = false,
  formik,
  handleChange,
  question,
  handleNextButton,
  isConfirmButton = false,
  ref,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fieldName,
  ...rest
}: PhoneProps & React.HTMLProps<HTMLInputElement>) => {
  const [value, setValue] = useState(formik.values[question.code]);

  const onChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const { rawValue } = event.target as any;

    setValue(rawValue);

    const modifiedEvent = event;
    modifiedEvent.target.value = rawValue;

    handleChange?.(modifiedEvent, rawValue);
  };

  const shouldUseShortPrefix = useMemo(
    () => value?.match(/^(02|03|04|05|07).*/),
    [value]
  );

  useEffect(() => {
    // And trigger manual focus when our condition is meet
    // Problem is that it will trigger a focus at page load
    ref?.focus();
  }, [shouldUseShortPrefix, ref]);

  return (
    <TextFieldLayout
      t={t}
      tip={question.tipText}
      label={t(question.label)}
      questionCode={question.code}
      showNextButton={showNextButton}
      isVisible={isVisible}
      handleNextButton={handleNextButton}
      isConfirmButton={isConfirmButton}
      formik={formik}
    >
      {(handleKeyDown: KeyboardEventHandler<HTMLInputElement>) => {
        const isValid =
          formik.touched[question.code] && !formik.errors[question.code];
        const isInvalid =
          formik.touched[question.code] && formik.errors[question.code];

        const onKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
          handleKeyDown(e);
          rest?.onKeyDown?.(e);
        };

        const onPaste = (e: React.ClipboardEvent<HTMLInputElement>) => {
          const regExp = /^\d+$/;
          const clipboad = e.clipboardData.getData('text');
          if (!regExp.test(clipboad)) {
            e.preventDefault();
          }
          rest?.onPaste?.(e);
        };

        return (
          <Cleave
            {...rest}
            htmlRef={(r) => {
              // eslint-disable-next-line no-param-reassign
              ref = r;
            }}
            type="tel"
            maxLength={12}
            className={clsx([
              'form-control',
              isValid && 'is-valid',
              isInvalid && 'is-invalid',
            ])}
            name={question.code}
            onChange={onChange}
            onPaste={onPaste}
            onBlur={onChange}
            onKeyDown={onKeyDown}
            data-testid="phone-input"
            // 1. Cleave does not track option changes
            // 2. so we need to trigger a rerender when our rule is meet
            key={shouldUseShortPrefix ? 'short-prefix' : 'normal-prefix'}
            // 3. above key will rerender Cleave with new options
            // 4. but focus is lost
            options={{
              blocks: shouldUseShortPrefix ? [2, 3, 4] : [3, 3, 4],
              delimiter: '-',
              numericOnly: true,
            }}
            value={value}
            placeholder={t('common:placeholders.phone')}
          />
        );
      }}
    </TextFieldLayout>
  );
};

export default Phone;
